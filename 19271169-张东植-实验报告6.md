# 19271169-张东植-实验报告6

[TOC]

​	

- **Gitlab repo: http://202.205.102.126:88/ZhangDongZhi/os-lab.git**



​	The main purpose of this experiment is to achieve dynamic memory application and release management. Through this experiment, dynamic memory application and release management can be realized. It includes dynamic memory allocation, basic definition of virtual address and physical address, data structure of page table, management and allocation of physical frame, multilevel page table management, address space of kernel and application, etc.

# 1. 实现内核支持动态内存分配

​	Since there is no standard library support in the operating system kernel, we need to implement the basic dynamic memory allocator using the interface defined by the Alloc library. Since the implementation of the memory allocator is complicated, the existing partner allocator is used directly.

1. First, add dependencies to the **"cargo.toml"** file. At the same time, we also need to introduce the dependency of **alloc** library in "**main.rs**", and add the following code.

   ```rust
   buddy_system_allocator = "0.6"
   
   // os/src/main.rs
   extern crate alloc;
   ```

   ![image-20211112232908343](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112232908343.png)

   ![image-20211112232813309](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112232813309.png)

2. Provides a global dynamic memory allocator based on the structure left by alloc. Also, we need to deal with dynamic memory allocation failures.

   ```rust
   // os/src/mm/heap_allocator.rs
   
   use buddy_system_allocator::LockedHeap;
   use crate::config::KERNEL_HEAP_SIZE;
   
   #[global_allocator]
   static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty();
   
   static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE];
   
   pub fn init_heap() {
       unsafe {
           HEAP_ALLOCATOR
               .lock()
               .init(HEAP_SPACE.as_ptr() as usize, KERNEL_HEAP_SIZE);
       }
   }
   
   // os/src/main.rs
   #![feature(alloc_error_handler)]
   
   // os/src/mm/heap_allocator.rs
   #[alloc_error_handler]
   pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {
       panic!("Heap allocation error, layout = {:?}", layout);
   }
   ```

   ![image-20211112233130854](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233130854.png)

   ![image-20211112233033712](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233033712.png)

   ![image-20211112233145805](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233145805.png)

3. Then, the implementation tests dynamic memory allocation.

   ```rust
   // os/src/mm/heap_allocator.rs
   
   #[allow(unused)]
   pub fn heap_test() {
       use alloc::boxed::Box;
       use alloc::vec::Vec;
       extern "C" {
           fn sbss();
           fn ebss();
       }
       let bss_range = sbss as usize..ebss as usize;
       let a = Box::new(5);
       assert_eq!(*a, 5);
       assert!(bss_range.contains(&(a.as_ref() as *const _ as usize)));
       drop(a);
       let mut v: Vec<usize> = Vec::new();
       for i in 0..500 {
           v.push(i);
       }
       for i in 0..500 {
           assert_eq!(v[i], i);
       }
       assert!(bss_range.contains(&(v.as_ptr() as usize)));
       drop(v);
       println!("heap_test passed!");
   }
   ```

   ![image-20211112233221615](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233221615.png)

4. Finally, modify other parts of the code.

   ```rust
   // os/src/main.rs
   mod mm;
   
   mm::init();
   
   
   // os/src/config.rs
   pub const KERNEL_HEAP_SIZE: usize = 0x30_0000;
   
   // os/src/mm/mod.rs
   
   mod heap_allocator;
   
   pub fn init() {
       heap_allocator::init_heap();
       heap_allocator::heap_test();
   }
   ```

   ![image-20211112233257720](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233257720.png)

![image-20211112233320716](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233320716.png)

![image-20211112233345755](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233345755.png)



# 2. 实现虚拟地址与物理地址

​	This section implements the virtual address and physical address data structure.

## 2.1 Data Structure Definition	

​	First, define the basic data structures required, including physical address, virtual address, physical page number, and virtual page number. Besides, implement conversions between these types and usize.

```rust
#[repr(C)]
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysAddr(pub usize);

#[repr(C)]
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtAddr(pub usize);

#[repr(C)]
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysPageNum(pub usize);

#[repr(C)]
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtPageNum(pub usize);

impl From<usize> for PhysAddr {
    fn from(v: usize) -> Self { Self(v) }
}
impl From<usize> for PhysPageNum {
    fn from(v: usize) -> Self { Self(v) }
}
impl From<usize> for VirtAddr {
    fn from(v: usize) -> Self { Self(v) }
}
impl From<usize> for VirtPageNum {
    fn from(v: usize) -> Self { Self(v) }
}
impl From<PhysAddr> for usize {
    fn from(v: PhysAddr) -> Self { v.0 }
}
impl From<PhysPageNum> for usize {
    fn from(v: PhysPageNum) -> Self { v.0 }
}
impl From<VirtAddr> for usize {
    fn from(v: VirtAddr) -> Self { v.0 }
}
impl From<VirtPageNum> for usize {
    fn from(v: VirtPageNum) -> Self { v.0 }
}
```

![image-20211112234016450](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234016450.png)

![image-20211112233905895](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233905895.png)

## 2.2 Convert between Page and Address 

​	Then, implement the convert between physical address and page number.

```rust
impl VirtAddr {
    pub fn floor(&self) -> VirtPageNum { VirtPageNum(self.0 / PAGE_SIZE) }
    pub fn ceil(&self) -> VirtPageNum  { VirtPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE) }
    pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) }
    pub fn aligned(&self) -> bool { self.page_offset() == 0 }
}

impl From<VirtAddr> for VirtPageNum {
    fn from(v: VirtAddr) -> Self {
        assert_eq!(v.page_offset(), 0);
        v.floor()
    }
}

impl From<VirtPageNum> for VirtAddr {
    fn from(v: VirtPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) }
}

impl PhysAddr {
    pub fn floor(&self) -> PhysPageNum { PhysPageNum(self.0 / PAGE_SIZE) }
    pub fn ceil(&self) -> PhysPageNum { PhysPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE) }
    pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) }
    pub fn aligned(&self) -> bool { self.page_offset() == 0 }
}

impl From<PhysAddr> for PhysPageNum {
    fn from(v: PhysAddr) -> Self {
        assert_eq!(v.page_offset(), 0);
        v.floor()
    }
}

impl From<PhysPageNum> for PhysAddr {
    fn from(v: PhysPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) }
}
```

![image-20211112234121259](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234121259.png)

## 2.3 Indexed Search

​	Finally, achieve query index and other content.

```rust
use crate::config::{PAGE_SIZE, PAGE_SIZE_BITS};
use super::PageTableEntry;
use core::fmt::{self, Debug, Formatter};

/// Debugging
impl Debug for VirtAddr {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("VA:{:#x}", self.0))
    }
}
impl Debug for VirtPageNum {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("VPN:{:#x}", self.0))
    }
}
impl Debug for PhysAddr {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("PA:{:#x}", self.0))
    }
}
impl Debug for PhysPageNum {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("PPN:{:#x}", self.0))
    }
}

impl VirtPageNum {
    pub fn indexes(&self) -> [usize; 3] {
        let mut vpn = self.0;
        let mut idx = [0usize; 3];
        for i in (0..3).rev() {
            idx[i] = vpn & 511;
            vpn >>= 9;
        }
        idx
    }
}

impl PhysPageNum {
    pub fn get_pte_array(&self) -> &'static mut [PageTableEntry] {
        let pa: PhysAddr = self.clone().into();
        unsafe {
            core::slice::from_raw_parts_mut(pa.0 as *mut PageTableEntry, 512)
        }
    }
    pub fn get_bytes_array(&self) -> &'static mut [u8] {
        let pa: PhysAddr = self.clone().into();
        unsafe {
            core::slice::from_raw_parts_mut(pa.0 as *mut u8, 4096)
        }
    }
    pub fn get_mut<T>(&self) -> &'static mut T {
        let pa: PhysAddr = self.clone().into();
        unsafe {
            (pa.0 as *mut T).as_mut().unwrap()
        }
    }
}

pub trait StepByOne {
    fn step(&mut self);
}
impl StepByOne for VirtPageNum {
    fn step(&mut self) {
        self.0 += 1;
    }
}

#[derive(Copy, Clone)]
pub struct SimpleRange<T> where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug, {
    l: T,
    r: T,
}
impl<T> SimpleRange<T> where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug, {
    pub fn new(start: T, end: T) -> Self {
        assert!(start <= end, "start {:?} > end {:?}!", start, end);
        Self { l: start, r: end }
    }
    pub fn get_start(&self) -> T { self.l }
    pub fn get_end(&self) -> T { self.r }
}
impl<T> IntoIterator for SimpleRange<T> where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug, {
    type Item = T;
    type IntoIter = SimpleRangeIterator<T>;
    fn into_iter(self) -> Self::IntoIter {
        SimpleRangeIterator::new(self.l, self.r)
    }
}
pub struct SimpleRangeIterator<T> where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug, {
    current: T,
    end: T,
}
impl<T> SimpleRangeIterator<T> where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug, {
    pub fn new(l: T, r: T) -> Self {
        Self { current: l, end: r, }
    }
}
impl<T> Iterator for SimpleRangeIterator<T> where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug, {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        if self.current == self.end {
            None
        } else {
            let t = self.current;
            self.current.step();
            Some(t)
        }
    }
}
pub type VPNRange = SimpleRange<VirtPageNum>;
```

![image-20211112234103482](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234103482.png)

![image-20211112233847501](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112233847501.png)

![image-20211112234136320](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234136320.png)

![image-20211112234145515](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234145515.png)



# 3. 页表项数据结构定义

​	To implement the page table entry definition, we need to use **crate bitflags** of the bits commonly used in Rust.

## 3.1 Flag bit

​	First, implement the flag bit **PTEFlags** in the page table entry.

```rust
// os/src/main.rs
#[macro_use]
extern crate bitflags;

// os/src/mm/page_table.rs
use bitflags::*;

bitflags! {
    pub struct PTEFlags: u8 {
        const V = 1 << 0;
        const R = 1 << 1;
        const W = 1 << 2;
        const X = 1 << 3;
        const U = 1 << 4;
        const G = 1 << 5;
        const A = 1 << 6;
        const D = 1 << 7;
    }
}
```

![image-20211112234547690](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234547690.png)

## 3.2 Dependencies 

​	Meanwhile, we need to add **bitflgs** dependencies to the config file.

![image-20211112234628565](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234628565.png)

## 3.3 Table Entry

​	Implement **Page Table Entry** in file **"page_table.rs"**, and add usages in file **"mod.rs"**.

```rust
//os/src/mm/page_table.rs
use super::{frame_alloc, PhysPageNum, FrameTracker, VirtPageNum, VirtAddr, StepByOne};

#[derive(Copy, Clone)]
#[repr(C)]
pub struct PageTableEntry {
    pub bits: usize,
}

impl PageTableEntry {
    pub fn new(ppn: PhysPageNum, flags: PTEFlags) -> Self {
        PageTableEntry {
            bits: ppn.0 << 10 | flags.bits as usize,
        }
    }
    pub fn empty() -> Self {
        PageTableEntry {
            bits: 0,
        }
    }
    pub fn ppn(&self) -> PhysPageNum {
        (self.bits >> 10 & ((1usize << 44) - 1)).into()
    }
    pub fn flags(&self) -> PTEFlags {
        PTEFlags::from_bits(self.bits as u8).unwrap()
    }
    pub fn is_valid(&self) -> bool {
        (self.flags() & PTEFlags::V) != PTEFlags::empty()
    }
    pub fn readable(&self) -> bool {
        (self.flags() & PTEFlags::R) != PTEFlags::empty()
    }
    pub fn writable(&self) -> bool {
        (self.flags() & PTEFlags::W) != PTEFlags::empty()
    }
    pub fn executable(&self) -> bool {
        (self.flags() & PTEFlags::X) != PTEFlags::empty()
    }
}
```

![image-20211112234837239](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234837239.png)

```rust
// mod.rs
mod page_table;

use page_table::{PTEFlags};
pub use page_table::{PageTableEntry};
```

![image-20211112234914665](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112234914665.png)



# 4. 物理帧的管理与分配

​	This section includes the implementations of managing and distributing physical frames.

## 4.1 End-address Settings

​	In file **"linker.ld"**,  **ekernel** determines the end address of kernel data, after which all physical memory is available. We limit the size of physical memory by setting parameters in the **"config"** submodule.

```rust
// os/src/config.rs
pub const MEMORY_END: usize = 0x80800000;
```

![image-20211112235548854](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112235548854.png)

## 4.2 Frame Management

​	Implement this part in file **"frame_allocator.rs"**.

```rust
use super::{PhysAddr, PhysPageNum};
use alloc::vec::Vec;
use spin::Mutex;
use crate::config::MEMORY_END;
use lazy_static::*;
use core::fmt::{self, Debug, Formatter};

pub struct FrameTracker {
    pub ppn: PhysPageNum,
}

impl FrameTracker {
    pub fn new(ppn: PhysPageNum) -> Self {
        // page cleaning
        let bytes_array = ppn.get_bytes_array();
        for i in bytes_array {
            *i = 0;
        }
        Self { ppn }
    }
}

impl Debug for FrameTracker {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("FrameTracker:PPN={:#x}", self.ppn.0))
    }
}

impl Drop for FrameTracker {
    fn drop(&mut self) {
        frame_dealloc(self.ppn);
    }
}

trait FrameAllocator {
    fn new() -> Self;
    fn alloc(&mut self) -> Option<PhysPageNum>;
    fn dealloc(&mut self, ppn: PhysPageNum);
}

pub struct StackFrameAllocator {
    current: usize,
    end: usize,
    recycled: Vec<usize>,
}

impl StackFrameAllocator {
    pub fn init(&mut self, l: PhysPageNum, r: PhysPageNum) {
        self.current = l.0;
        self.end = r.0;
        println!("last {} Physical Frames.", self.end - self.current);
    }
}
impl FrameAllocator for StackFrameAllocator {
    fn new() -> Self {
        Self {
            current: 0,
            end: 0,
            recycled: Vec::new(),
        }
    }
    fn alloc(&mut self) -> Option<PhysPageNum> {
        if let Some(ppn) = self.recycled.pop() {
            Some(ppn.into())
        } else {
            if self.current == self.end {
                None
            } else {
                self.current += 1;
                Some((self.current - 1).into())
            }
        }
    }
    fn dealloc(&mut self, ppn: PhysPageNum) {
        let ppn = ppn.0;
        // validity check
        if ppn >= self.current || self.recycled
            .iter()
            .find(|&v| {*v == ppn})
            .is_some() {
            panic!("Frame ppn={:#x} has not been allocated!", ppn);
        }
        // recycle
        self.recycled.push(ppn);
    }
}

type FrameAllocatorImpl = StackFrameAllocator;

lazy_static! {
    pub static ref FRAME_ALLOCATOR: UPSafeCell<FrameAllocatorImpl> = unsafe {
        UPSafeCell::new(FrameAllocatorImpl::new())
    };
}

pub fn init_frame_allocator() {
    extern "C" {
        fn ekernel();
    }
    FRAME_ALLOCATOR
        .exclusive_access()
        .init(PhysAddr::from(ekernel as usize).ceil(), PhysAddr::from(MEMORY_END).floor());
}

pub fn frame_alloc() -> Option<FrameTracker> {
    FRAME_ALLOCATOR
        .exclusive_access()
        .alloc()
        .map(|ppn| FrameTracker::new(ppn))
}

fn frame_dealloc(ppn: PhysPageNum) {
    FRAME_ALLOCATOR
        .exclusive_access()
        .dealloc(ppn);
}

#[allow(unused)]
pub fn frame_allocator_test() {
    let mut v: Vec<FrameTracker> = Vec::new();
    for i in 0..5 {
        let frame = frame_alloc().unwrap();
        println!("{:?}", frame);
        v.push(frame);
    }
    v.clear();
    for i in 0..5 {
        let frame = frame_alloc().unwrap();
        println!("{:?}", frame);
        v.push(frame);
    }
    drop(v);
    println!("frame_allocator_test passed!");
}
```

​	Because the **mutex** is used to wrap the stack physical page-frame allocator, "**spin crate**" also needs to be introduced in the config file.

```rust
//os/Cargo.toml
spin = "0.7.0"
```

![image-20211112235437713](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112235437713.png)

## 4.3 Test

​	In order to implement the physical frame management test, we also need to modify some parts of the codes.

```rust
//os/src/config.rs
pub const PAGE_SIZE: usize = 0x1000;
pub const PAGE_SIZE_BITS: usize = 0xc;

//os/src/mm/mod.rs
mod address;
mod frame_allocator;

pub use address::{PhysAddr, VirtAddr, PhysPageNum, VirtPageNum, StepByOne};
pub use frame_allocator::{FrameTracker, frame_alloc};

pub fn init() {
    heap_allocator::init_heap();
    heap_allocator::heap_test();
    frame_allocator::init_frame_allocator();
    frame_allocator::frame_allocator_test();
}
```

​	In the end, verify that the physical frame allocation test is successful by executing "**make run**".



# 5. 多级页表管理

​	This section includes the implementations of multi-level page table management.

## 5.1 Page Table Structure

​	Implement the basic data structure of the page table.

```rust
// os/src/mm/page_table.rs
use alloc::vec::Vec;
use alloc::vec;

pub struct PageTable {
    root_ppn: PhysPageNum,
    frames: Vec<FrameTracker>,
}

impl PageTable {
    pub fn new() -> Self {
        let frame = frame_alloc().unwrap();
        PageTable {
            root_ppn: frame.ppn,
            frames: vec![frame],
        }
    }
}
```

![image-20211112235823928](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112235823928.png)

## 5.2 Mapping between Virtual & Physical

​	Besides, we need to be able to establish and remove the mapping between virtual and physical addresses.

```rust
// os/src/mm/page_table.rs

impl PageTable {
    fn find_pte_create(&mut self, vpn: VirtPageNum) -> Option<&mut PageTableEntry> {
        let idxs = vpn.indexes();
        let mut ppn = self.root_ppn;
        let mut result: Option<&mut PageTableEntry> = None;
        for i in 0..3 {
            let pte = &mut ppn.get_pte_array()[idxs[i]];
            if i == 2 {
                result = Some(pte);
                break;
            }
            if !pte.is_valid() {
                let frame = frame_alloc().unwrap();
                *pte = PageTableEntry::new(frame.ppn, PTEFlags::V);
                self.frames.push(frame);
            }
            ppn = pte.ppn();
        }
        result
    }

    #[allow(unused)]
    pub fn map(&mut self, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) {
        let pte = self.find_pte_create(vpn).unwrap();
        assert!(!pte.is_valid(), "vpn {:?} is mapped before mapping", vpn);
        *pte = PageTableEntry::new(ppn, flags | PTEFlags::V);
    }

    #[allow(unused)]
    pub fn unmap(&mut self, vpn: VirtPageNum) {
        let pte = self.find_pte_create(vpn).unwrap();
        assert!(pte.is_valid(), "vpn {:?} is invalid before unmapping", vpn);
        *pte = PageTableEntry::empty();
    }
}
```

![image-20211113000146331](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211113000146331.png)

![image-20211113000155215](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211113000155215.png)

## 5.3 Manual Query

​	Meanwhile, in order to facilitate the subsequent implementation, also provides a manual query page table method

```rust
// os/src/mm/page_table.rs

impl PageTable {
    /// Temporarily used to get arguments from user space.
    pub fn from_token(satp: usize) -> Self {
        Self {
            root_ppn: PhysPageNum::from(satp & ((1usize << 44) - 1)),
            frames: Vec::new(),
        }
    }
    
    fn find_pte(&self, vpn: VirtPageNum) -> Option<&PageTableEntry> {
        let idxs = vpn.indexes();
        let mut ppn = self.root_ppn;
        let mut result: Option<&PageTableEntry> = None;
        for i in 0..3 {
            let pte = &ppn.get_pte_array()[idxs[i]];
            if i == 2 {
                result = Some(pte);
                break;
            }
            if !pte.is_valid() {
                return None;
            }
            ppn = pte.ppn();
        }
        result
    }
    
    pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> {
        self.find_pte(vpn)
            .map(|pte| {pte.clone()})
    }
    pub fn token(&self) -> usize {
        8usize << 60 | self.root_ppn.0
    }
}
```

![image-20211113000114660](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211113000114660.png)

![image-20211113000125945](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211113000125945.png)



# 6. 内核与应用的地址空间

​	This section includes the implementations of the address space of the kernel and the application.

## 6.1 Address space Abstraction

1. Firstly, a logical segment **MapArea** is used to describe the virtual memory of a contiguous address. VPNRange is a continuous space of virtual page numbers. Implemented in the Address submodule.

   ```rust
   // os/src/mm/memory_set.rs
   
   pub struct MapArea {
       vpn_range: VPNRange,
       data_frames: BTreeMap<VirtPageNum, FrameTracker>,
       map_type: MapType,
       map_perm: MapPermission,
   }
   ```

   ![image-20211114122059338](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114122059338.png)

2. Next, MapType is used to describe how all virtual page numbers in the logical segment are mapped to physical page frames. At the same time, MapPermisssion is used to control the access mode of the logical segment, which is a subset of the PTEFlags of the page table entry.

   ```rust
   // os/src/mm/memory_set.rs
   
   #[derive(Copy, Clone, PartialEq, Debug)]
   pub enum MapType {
       Identical,
       Framed,
   }
   
   bitflags! {
       pub struct MapPermission: u8 {
           const R = 1 << 1;
           const W = 1 << 2;
           const X = 1 << 3;
           const U = 1 << 4;
       }
   }
   ```

   ![image-20211114122129731](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114122129731.png)

3. We can then implement an address space, which is a series of related logical segments, represented by a **MemorySet**. At the same time, the MemorySet method is implemented.

   ```rust
   // os/src/mm/memory_set.rs
   
   pub struct MemorySet {
       page_table: PageTable,
       areas: Vec<MapArea>,
   }
   
   impl MemorySet {
       pub fn new_bare() -> Self {
           Self {
               page_table: PageTable::new(),
               areas: Vec::new(),
           }
       }
       pub fn token(&self) -> usize {
           self.page_table.token()
       }
       /// Assume that no conflicts.
       pub fn insert_framed_area(&mut self, start_va: VirtAddr, end_va: VirtAddr, permission: MapPermission) {
           self.push(MapArea::new(
               start_va,
               end_va,
               MapType::Framed,
               permission,
           ), None);
       }
       fn push(&mut self, mut map_area: MapArea, data: Option<&[u8]>) {
           map_area.map(&mut self.page_table);
           if let Some(data) = data {
               map_area.copy_data(&mut self.page_table, data);
           }
           self.areas.push(map_area);
       }
       /// Mention that trampoline is not collected by areas.
       fn map_trampoline(&mut self) {
           self.page_table.map(
               VirtAddr::from(TRAMPOLINE).into(),
               PhysAddr::from(strampoline as usize).into(),
               PTEFlags::R | PTEFlags::X,
           );
       }
       pub fn activate(&self) {
           let satp = self.page_table.token();
           unsafe {
               satp::write(satp);
               asm!("sfence.vma");
           }
       }
       pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> {
           self.page_table.translate(vpn)
       }
   }
   ```

![image-20211114122154275](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114122154275.png)



## 6.2 Kernel address space

​	Implement the method of creating the kernel address space **"new_kernel"**.

![image-20211114122313930](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114122313930.png)

## 6.3 Application address space

​	Since the application is dynamically loaded, all applications use the same link script. Pay particular attention to changing BASE_ADDRESS to 0x0. 

```rust
// user/src/linker.ld 
OUTPUT_ARCH(riscv)
ENTRY(_start)

BASE_ADDRESS = 0x0;

SECTIONS
{
    . = BASE_ADDRESS;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    . = ALIGN(4K);
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }
    . = ALIGN(4K);
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }
    .bss : {
        start_bss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
        end_bss = .;
    }
    /DISCARD/ : {
        *(.eh_frame)
        *(.debug*)
    }
}
```

![image-20211114125949518](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114125949518.png)

​	And we can modify the thin Loader submodule now that we can use ELF executable files directly. At the same time, the ELF format data needs to be parsed to get a complete application address space. Because xMAS-ELF is used, you need to add dependencies in the configuration file Cargo. Toml.

```rust
// os/src/loader.rs
pub fn get_num_app() -> usize {
    extern "C" { fn _num_app(); }
    unsafe { (_num_app as usize as *const usize).read_volatile() }
}

pub fn get_app_data(app_id: usize) -> &'static [u8] {
    extern "C" { fn _num_app(); }
    let num_app_ptr = _num_app as usize as *const usize;
    let num_app = get_num_app();
    let app_start = unsafe {
        core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)
    };
    assert!(app_id < num_app);
    unsafe {
        core::slice::from_raw_parts(
            app_start[app_id] as *const u8,
            app_start[app_id + 1] - app_start[app_id]
        )
    }
}

// os/Cargo.toml
xmas-elf = "0.7.0"
```

![image-20211114130020171](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130020171.png)

​	Finally, note that implementing the memory_set submodule also adds the following code:

```rust
//os/src/mm/memory_set.rs
use super::{PageTable, PageTableEntry, PTEFlags};
use super::{VirtPageNum, VirtAddr, PhysPageNum, PhysAddr};
use super::{FrameTracker, frame_alloc};
use super::{VPNRange, StepByOne};
use alloc::collections::BTreeMap;
use alloc::vec::Vec;
use riscv::register::satp;
use alloc::sync::Arc;
use lazy_static::*;
use crate::sync::UPSafeCell;
use crate::config::{
    MEMORY_END,
    PAGE_SIZE,
    TRAMPOLINE,
    TRAP_CONTEXT,
    USER_STACK_SIZE
};

//os/src/config.rs
pub const TRAMPOLINE: usize = usize::MAX - PAGE_SIZE + 1;
pub const TRAP_CONTEXT: usize = TRAMPOLINE - PAGE_SIZE;
```



# 7. 实现基于地址空间的分时多任务

​	This section includes the implementations of the time-sharing multi-task based on address space.

## 7.1 Virtual address space on paging mode

1. First, create the kernel address space.

   ```rust
   // os/src/mm/memory_set.rs
   lazy_static! {
       pub static ref KERNEL_SPACE: Arc<UPSafeCell<MemorySet>> = Arc::new(unsafe {
           UPSafeCell::new(MemorySet::new_kernel()
       )});
   }
   ```

   ![image-20211114130152271](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130152271.png)

2. The memory management subsystem is then initialized in rust_main.

   ```rust
   // os/src/mm/mod.rs
   mod memory_set;
   
   use page_table::{PageTable, PTEFlags};
   pub use frame_allocator::{FrameTracker, frame_alloc, frame_dealloc};
   pub use page_table::{PageTableEntry, translated_byte_buffer};
   pub use memory_set::{MemorySet, KERNEL_SPACE, MapPermission};
   
   pub fn init() {
       heap_allocator::init_heap();
       frame_allocator::init_frame_allocator();
       KERNEL_SPACE.exclusive_access().activate();
   }
   ```

   ![image-20211114130219641](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130219641.png)

3. Next, check the multi-level page table Settings for the kernel address space.

   ```rust
   // os/src/mm/memory_set.rs
   #[allow(unused)]
   pub fn remap_test() {
       let mut kernel_space = KERNEL_SPACE.exclusive_access();
       let mid_text: VirtAddr = ((stext as usize + etext as usize) / 2).into();
       let mid_rodata: VirtAddr = ((srodata as usize + erodata as usize) / 2).into();
       let mid_data: VirtAddr = ((sdata as usize + edata as usize) / 2).into();
       assert_eq!(
           kernel_space.page_table.translate(mid_text.floor()).unwrap().writable(),
           false
       );
       assert_eq!(
           kernel_space.page_table.translate(mid_rodata.floor()).unwrap().writable(),
           false,
       );
       assert_eq!(
           kernel_space.page_table.translate(mid_data.floor()).unwrap().executable(),
           false,
       );
       println!("remap_test passed!");
   }
   ```

   ![image-20211114130310555](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130310555.png)

## 7.2 Springboard Mechanism

​		This page is called a springboard page because the assembly code for this page switches address Spaces during execution.

1. First, extend the Trap protocol.

   ```rust
   //os/src/trap/context.rs
   #[repr(C)]
   pub struct TrapContext {
       pub x: [usize; 32],
       pub sstatus: Sstatus,
       pub sepc: usize,
       pub kernel_satp: usize,
       pub kernel_sp: usize,
       pub trap_handler: usize,
   }
   
   impl TrapContext {
       pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; }
       pub fn app_init_context(
           entry: usize,
           sp: usize,
           kernel_satp: usize,
           kernel_sp: usize,
           trap_handler: usize,
       ) -> Self {
           let mut sstatus = sstatus::read();
           sstatus.set_spp(SPP::User);
           let mut cx = Self {
               x: [0; 32],
               sstatus,
               sepc: entry,
               kernel_satp,
               kernel_sp,
               trap_handler,
           };
           cx.set_sp(sp);
           cx
       }
   }
   ```

   ![image-20211114130523956](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130523956.png)

2. Then, the address space is switched.

   ![image-20211114130552111](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130552111.png)

3. Then, create the springboard page. Place the entire assembly code in "**trap.s**" in ".text.trampoline" segment and align it to a page of the segment when adjusting the memory layout.

   ```rust
   # os/src/linker.ld
   
   stext = .;
   .text : {
       *(.text.entry)
       . = ALIGN(4K);
       strampoline = .;
       *(.text.trampoline);
       . = ALIGN(4K);
       *(.text .text.*)
   }
   ```

   ![image-20211114130624421](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130624421.png)

## 7.3 Application loading and execution

1. First, modify the task submodule and update the management of the task control block.

   ```rust
   // os/src/config.rs
   /// Return (bottom, top) of a kernel stack in kernel space.
   pub fn kernel_stack_position(app_id: usize) -> (usize, usize) {
       let top = TRAMPOLINE - app_id * (KERNEL_STACK_SIZE + PAGE_SIZE);
       let bottom = top - KERNEL_STACK_SIZE;
       (bottom, top)
   }
   ```

   ![image-20211114130815893](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130815893.png)

2. At kernel initialization time, all applications need to be loaded into the global application manager. Also, modify the **TaskManager** implementation. Modify "**switch.S**", and at the same time, modify "**switch.rs**".

   ![image-20211114130902284](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130902284.png)

   ![image-20211114130920565](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130920565.png)

   ![image-20211114130933780](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114130933780.png)

3. In addition, you need to add the sync module to implement **UPSafeCell**.

![image-20211114131013049](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131013049.png)



## 7.4 Trap handling

1. First modify the "**init**" function. Then add "**set_kernel_trap_entry**" to the beginning of trap_handler. At the same time, after the trap is processed, call "**trap_return**" to return the user state.

   ```rust
   //os/src/trap/mod.rs
   use crate::task::{
       current_user_token,
       current_trap_cx,
   };
   
   use crate::config::{TRAP_CONTEXT, TRAMPOLINE};
   
   pub fn init() {
       set_kernel_trap_entry();
   }
   
   fn set_kernel_trap_entry() {
       unsafe {
           stvec::write(trap_from_kernel as usize, TrapMode::Direct);
       }
   }
   
   fn set_user_trap_entry() {
       unsafe {
           stvec::write(TRAMPOLINE as usize, TrapMode::Direct);
       }
   }
   
   #[no_mangle]
   pub fn trap_handler() -> ! {
       set_kernel_trap_entry();
   
       ...
   }
   
   #[no_mangle]
   pub fn trap_return() -> ! {
       set_user_trap_entry();
   
       ...
   }
   
   #[no_mangle]
   pub fn trap_from_kernel() -> ! {
       panic!("a trap from kernel!");
   ```

   ![image-20211114131140997](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131140997.png)

2. At the same time, when each application first obtains CPU privileges, the top of the kernel stack is placed in a task context constructed when the kernel loads the application.

   ```rust
   //os/src/task/context.rs
   use crate::trap::trap_return;
   
   #[repr(C)]
   pub struct TaskContext {
       ra: usize,
       sp: usize,
       s: [usize; 12],
   }
   
   impl TaskContext {
       pub fn zero_init() -> Self {
           Self {
               ra: 0,
               sp: 0,
               s: [0; 12],
           }
       }
       pub fn goto_trap_return(kstack_ptr: usize) -> Self {
           Self {
               ra: trap_return as usize,
               sp: kstack_ptr,
               s: [0; 12],
           }
       }
   }
   ```

   ![image-20211114131213368](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131213368.png)



## 7.5 sys_write

​	"**sys_write**" cannot directly apply space data due to address space isolation. To this end, the page table **"page_table"** provides an auxiliary function that converts the buffer of the application address space into something directly accessible from the kernel address space. Thus, we can modify the **"sys_write"** system call.

```rust
//os/src/mm/page_table.rs
pub fn translated_byte_buffer(token: usize, ptr: *const u8, len: usize) -> Vec<&'static mut [u8]> {
    let page_table = PageTable::from_token(token);
    let mut start = ptr as usize;
    let end = start + len;
    let mut v = Vec::new();
    while start < end {
        let start_va = VirtAddr::from(start);
        let mut vpn = start_va.floor();
        let ppn = page_table
            .translate(vpn)
            .unwrap()
            .ppn();
        vpn.step();
        let mut end_va: VirtAddr = vpn.into();
        end_va = end_va.min(VirtAddr::from(end));
        if end_va.page_offset() == 0 {
            v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..]);
        } else {
            v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..end_va.page_offset()]);
        }
        start = end_va.into();
    }
    v
}
```

![image-20211114131407576](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131407576.png)

```rust
//os/src/syscall/fs.rs
use crate::mm::translated_byte_buffer;
use crate::task::current_user_token;

const FD_STDOUT: usize = 1;

pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize {
    match fd {
        FD_STDOUT => {
            let buffers = translated_byte_buffer(current_user_token(), buf, len);
            for buffer in buffers {
                print!("{}", core::str::from_utf8(buffer).unwrap());
            }
            len as isize
        },
        _ => {
            panic!("Unsupported fd in sys_write!");
        }
    }
}
```

![image-20211114131430418](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131430418.png)

# 8. 完善程序

1. Delete **"build.py"**. Since the starting address of the application is the same, you don't need build.py anymore, just delete it. Also, modify the Makefile file.

2. Modify **"main.rs"**.

   ![image-20211114131615018](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131615018.png)

3. Modify **"os/build.rs"**.

   ![image-20211114131633712](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131633712.png)

![image-20211114131826349](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211114131826349.png)



