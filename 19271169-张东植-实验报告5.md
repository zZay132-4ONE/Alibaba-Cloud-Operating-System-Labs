# 19271169-张东植-实验报告5

[TOC]

- **Gitlab repo: http://202.205.102.126:88/ZhangDongZhi/os-lab.git**



​	The main purpose of this experiment is to implement a time-sharing multi-task and preemptive scheduling operating system. Through this experiment, we can realize a time-sharing multi-task and preemptive scheduling operating system. This includes clock interrupt and timer, application modification, preemptive scheduling, etc.

# 1. 时钟中断与计时器

​	In risc-v 64 architecture, there are two status registers, **mtime** and **mtimecmp**. mtime counts the clock period of the built-in clock since power-on. mtimecmp triggers a clock interrupt when mtime exceeds mtimecmp.

1. First, implement the timer submodule to get the value of mtime.

   ```rust
   //os /src/timer.rs
   use riscv::register::time;
   
   pub fn get_time() -> usize {
       time::read()
   }
   ```

   ![image-20211112205648753](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112205648753.png)

2. Next, the value of mtimECMP is set in the SBI submodule implementation and encapsulated in the Timer submodule.

   ```rust
   //os/src/sbi.rs
   const SBI_SET_TIMER: usize = 0;
   
   pub fn set_timer(timer: usize) {
       sbi_call(SBI_SET_TIMER, timer, 0, 0);
   }
   
   //os/src/timer.rs
   use crate::sbi::set_timer;
   use crate::config::CLOCK_FREQ;
   
   const TICKS_PER_SEC: usize = 100;
   
   pub fn set_next_trigger() {
       set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);
   }
   ```

   ![image-20211112205734696](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112205734696.png)

3. At the same time, for subsequent timing operations, we also need to wrap another function in the timer submodule that returns the value of the current counter in milliseconds.

   ```rust
   //os/src/timer.rs
   const MSEC_PER_SEC: usize = 1000;
   
   pub fn get_time_ms() -> usize {
       time::read() / (CLOCK_FREQ / MSEC_PER_SEC)
   }
   ```

4. Since the above two functions use constants in "config.rs", so we should also modify file "**config.rs**".

   ```rust
   pub const CLOCK_FREQ: usize = 12500000;
   ```

5. Finally, we need to modify **"syscall"** submodule to add the implementation of the **get_time** system call. And add the following codes to file **"process.rs"**. Also, change OS/SRC /syscall/mod.rs to add get_time system call handling.

   ```rust
   use crate::timer::get_time_ms;
   
   pub fn sys_get_time() -> isize {
       get_time_ms() as isize
   }
   
   const SYSCALL_GET_TIME: usize = 169;
   
   SYSCALL_GET_TIME => sys_get_time(),
   ```

   ![image-20211112205826396](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112205826396.png)

   ![image-20211112205905704](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112205905704.png)



# 2. 修改程序

​	This section includes some modifications on the program to make it preemptive and time-sharing.

## 2.1 get_time

1. First, add the get_time system call to **"syscall.rs"** with the following code.

   ```rust
   //user/src/syscall.rs
   const SYSCALL_GET_TIME: usize = 169;
   
   pub fn sys_get_time() -> isize {
       syscall(SYSCALL_GET_TIME, [0, 0, 0])
   }
   ```

   ![image-20211112210235348](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210235348.png)

2. Then add the get_time user library wrapper to **"lib.rs"** and add the following code.

   ```rust
   //user/src/lib.rs
   pub fn get_time() -> isize { sys_get_time() }
   ```

   ![image-20211112210314167](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210314167.png)



## 2.2 Test Demo

- **00power_3.rs :** 

  ![image-20211112210413537](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210413537.png)

- **01power_5.rs :**

  ![image-20211112210433670](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210433670.png)

- **02power_7.rs :**

  ![image-20211112210457341](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210457341.png)

- **03sleep.rs :**

  ![image-20211112210522890](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210522890.png)



# 3. 抢占式调度

​	Once the clock interrupts and timers are complete, it's easy to implement preemptive scheduling. Modify file **"mod.rs"** code as below.

```rust
//os/src/trap/mod.rs

use riscv::register::{
    mtvec::TrapMode,
    stvec,
    scause::{
        self,
        Trap,
        Exception,
        Interrupt,
    },
    stval,
    sie,
};

use crate::task::{
    exit_current_and_run_next,
    suspend_current_and_run_next,
};

use crate::timer::set_next_trigger;


pub fn enable_timer_interrupt() {
    unsafe { sie::set_stimer(); }
}

#[no_mangle]
pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read();
    let stval = stval::read();
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            cx.sepc += 4;
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
        Trap::Exception(Exception::StoreFault) |
        Trap::Exception(Exception::StorePageFault) => {
            println!("[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, core dumped.", stval, cx.sepc);
            exit_current_and_run_next();
        }
        Trap::Exception(Exception::IllegalInstruction) => {
            println!("[kernel] IllegalInstruction in application, core dumped.");
            exit_current_and_run_next();
        }
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            set_next_trigger();
            suspend_current_and_run_next();
        }
        _ => {
            panic!("Unsupported trap {:?}, stval = {:#x}!", scause.cause(), stval);
        }
    }
    cx
}
```

![image-20211112210751619](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210751619.png)

​	In addition, we need to do some initialization work in "main.rs" before the first application executes. We need to add some codes to file **"main.rs"**.

```rust
mod timer;

trap::enable_timer_interrupt();
timer::set_next_trigger();
```

![image-20211112210820169](C:\Users\Dal-Z41\AppData\Roaming\Typora\typora-user-images\image-20211112210820169.png)

